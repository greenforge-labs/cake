# ============================================================================
# cake_auto_package.cmake
#
# Automated build system for ROS 2 packages with cake nodes. Expects nodes/ directory with subdirectories containing
# interface.yaml and C++ or Python implementation files.
# ============================================================================

# Detect which languages (C++ and/or Python) are present in a directory Args: DIR - Directory to scan for source files
# OUT_HAS_CPP - Output variable, set to TRUE if .cpp files found OUT_HAS_PYTHON - Output variable, set to TRUE if .py
# files found
function(_cake_detect_languages DIR OUT_HAS_CPP OUT_HAS_PYTHON)
    file(GLOB_RECURSE CPP_SOURCE_FILES "${DIR}/*.cpp")
    file(GLOB_RECURSE PY_SOURCE_FILES "${DIR}/*.py")

    set(${OUT_HAS_CPP} FALSE PARENT_SCOPE)
    set(${OUT_HAS_PYTHON} FALSE PARENT_SCOPE)

    if(CPP_SOURCE_FILES)
        set(${OUT_HAS_CPP} TRUE PARENT_SCOPE)
    endif()

    if(PY_SOURCE_FILES)
        set(${OUT_HAS_PYTHON} TRUE PARENT_SCOPE)
    endif()
endfunction()

# Convert snake_case to PascalCase (e.g., "my_node" -> "MyNode") Args: OUTPUT_VAR - Variable name to store the result
# INPUT_STRING - snake_case string to convert
function(_cake_snake_to_pascal OUTPUT_VAR INPUT_STRING)
    string(REPLACE "_" ";" WORD_LIST ${INPUT_STRING})
    set(RESULT "")

    foreach(WORD ${WORD_LIST})
        # Capitalize first letter
        string(SUBSTRING ${WORD} 0 1 FIRST_CHAR)
        string(TOUPPER ${FIRST_CHAR} FIRST_CHAR_UPPER)
        string(SUBSTRING ${WORD} 1 -1 REST)
        string(APPEND RESULT "${FIRST_CHAR_UPPER}${REST}")
    endforeach()

    set(${OUTPUT_VAR} ${RESULT} PARENT_SCOPE)
endfunction()

# Main entry point for cake build system Automates the entire build process for ROS 2 packages with cake nodes. Detects
# languages, generates interfaces, builds libraries, and registers components. Requires: nodes/ directory with at least
# one .cpp or .py file
function(cake_auto_package)
    find_package(ament_cmake_auto REQUIRED)
    ament_auto_find_build_dependencies()

    set(CAKE_NODES_DIR "${CMAKE_CURRENT_SOURCE_DIR}/nodes")

    if(NOT IS_DIRECTORY ${CAKE_NODES_DIR})
        message(FATAL_ERROR "cake: nodes/ directory not found at ${CAKE_NODES_DIR}")
    endif()

    _cake_detect_languages(${CAKE_NODES_DIR} HAS_CPP HAS_PYTHON)

    if(NOT HAS_CPP AND NOT HAS_PYTHON)
        message(FATAL_ERROR "cake: nodes/ directory has no C++ (.cpp) or Python (.py) files.")
    endif()

    if(HAS_CPP)
        # NOTE: CAKE_CPP_PACKAGE_TARGET is part of the cake cmake API
        set(CAKE_CPP_PACKAGE_TARGET "${PROJECT_NAME}" CACHE INTERNAL "")
        _cake_build_package_shared_cpp_library(${CAKE_CPP_PACKAGE_TARGET})
    endif()

    if(HAS_PYTHON)
        # set up python package
        find_package(ament_cmake_python REQUIRED)
        _ament_cmake_python_get_python_install_dir()
        _cake_create_top_level_python_package()
    endif()

    _cake_generate_nodes(${CAKE_NODES_DIR})

    # Finalize package with scoped header install directory (best practice). USE_SCOPED_HEADER_INSTALL_DIR is used so
    # that we behave the same way on Jazzy as with Kilted. As far as I can tell, this is a non-breaking change because
    # it also changes which include directory is set with ament_export_include_directories - i.e. it doesn't really
    # matter.
    ament_auto_package(USE_SCOPED_HEADER_INSTALL_DIR)
endfunction()

# Build shared C++ library for all C++ nodes Creates a shared library from all .cpp files in nodes/ directory
function(_cake_build_package_shared_cpp_library)
    # NOTE: this uses a slightly implicit path "nodes" because ament_auto_add_library uses a relative path we have
    # already checked the nodes directory exists in cake_auto_package before calling this function
    ament_auto_add_library(${CAKE_CPP_PACKAGE_TARGET} SHARED DIRECTORY nodes)
    target_compile_features(${CAKE_CPP_PACKAGE_TARGET} PUBLIC cxx_std_20)
    message(STATUS "cake: Created C++ library '${CAKE_CPP_PACKAGE_TARGET}'")
endfunction()

# Create top-level Python package __init__.py Generates and installs __init__.py to make package importable
function(_cake_create_top_level_python_package)
    # Create top-level __init__.py for the package
    set(PACKAGE_INIT_PY "${CMAKE_CURRENT_BINARY_DIR}/python_package_init/__init__.py")
    file(WRITE ${PACKAGE_INIT_PY} "# Auto-generated by cake_auto_package\n")
    install(FILES ${PACKAGE_INIT_PY} DESTINATION "${PYTHON_INSTALL_DIR}/${PROJECT_NAME}")
    message(STATUS "cake: Created Python package '${PROJECT_NAME}'")
endfunction()

# Discover and process all nodes in the nodes/ directory Args: NODES_DIR - Path to nodes/ directory containing node
# subdirectories
function(_cake_generate_nodes NODES_DIR)
    file(GLOB NODE_DIRS RELATIVE ${NODES_DIR} ${NODES_DIR}/*)
    if(NOT NODE_DIRS)
        message(WARNING "cake: No nodes found in ${NODES_DIR}")
        return()
    endif()

    message(STATUS "cake: Auto-generating nodes from ${NODES_DIR}")

    # find the generator script
    unset(cake_codegen_script_BIN CACHE)
    find_program(
        cake_codegen_script_BIN
        NAMES "generate_node_interface.py"
        PATHS "${cake_DIR}/../../../lib/cake"
        NO_DEFAULT_PATH
    )
    if(NOT cake_codegen_script_BIN)
        message(FATAL_ERROR "Could not find generate_node_interface.py in ${cake_DIR}/../../../lib/cake")
    endif()

    foreach(NODE_ENTRY ${NODE_DIRS})
        set(NODE_PATH "${NODES_DIR}/${NODE_ENTRY}")
        if(IS_DIRECTORY ${NODE_PATH})
            _cake_generate_node(${NODE_ENTRY} ${NODE_PATH})
        endif()
    endforeach()
endfunction()

# Process a single node and generate language-specific interfaces Validates interface.yaml exists and dispatches to C++
# or Python generation. Mixed language nodes are not supported. Args: NODE_NAME - Name of the node NODE_DIR - Full path
# to the node's directory
function(_cake_generate_node NODE_NAME NODE_DIR)
    set(INTERFACE_YAML "${NODE_DIR}/interface.yaml")
    if(NOT EXISTS ${INTERFACE_YAML})
        message(FATAL_ERROR "cake: Node '${NODE_NAME}' is missing interface.yaml.")
    endif()

    _cake_detect_languages(${NODE_DIR} HAS_CPP HAS_PYTHON)
    if(HAS_CPP AND HAS_PYTHON)
        message(
            FATAL_ERROR
                "cake: Node '${NODE_NAME}' has both C++ and Python files. Mixed language nodes are not supported."
        )
    elseif(NOT HAS_CPP AND NOT HAS_PYTHON)
        message(FATAL_ERROR "cake: Node '${NODE_NAME}' has no C++ (.cpp) or Python (.py) files.")
    endif()

    if(HAS_CPP)
        _cake_generate_cpp_node(${NODE_NAME} ${INTERFACE_YAML})
    endif()

    if(HAS_PYTHON)
        _cake_generate_python_node(${NODE_NAME} ${NODE_DIR} ${INTERFACE_YAML})
    endif()
endfunction()

# Generate C++ interface, parameters, and component registration Creates interface header, parameter library, and
# registers as rclcpp_component. Plugin class follows pattern: ${PROJECT_NAME}::${NODE_NAME}::${NodeNamePascal} Args:
# NODE_NAME - Name of the node INTERFACE_YAML - Path to interface.yaml file
function(_cake_generate_cpp_node NODE_NAME INTERFACE_YAML)
    find_package(rclcpp REQUIRED)
    find_package(rclcpp_components REQUIRED)
    find_package(generate_parameter_library REQUIRED)

    set(LIB_INCLUDE_DIR ${CMAKE_CURRENT_BINARY_DIR}/include/${PROJECT_NAME})
    file(MAKE_DIRECTORY ${LIB_INCLUDE_DIR})

    set(INTERFACE_HEADER_FILE ${LIB_INCLUDE_DIR}/${NODE_NAME}_interface.hpp)
    set(INTERFACE_PARAMS_FILE ${LIB_INCLUDE_DIR}/${NODE_NAME}_interface.params.yaml)

    set(
        CODEGEN_CMD
        ${cake_codegen_script_BIN}
        ${INTERFACE_YAML}
        --language
        cpp
        --package
        ${PROJECT_NAME}
        --node-name
        ${NODE_NAME}
        --output
        ${LIB_INCLUDE_DIR}
    )

    add_custom_command(
        OUTPUT ${INTERFACE_HEADER_FILE} ${INTERFACE_PARAMS_FILE}
        COMMAND ${CODEGEN_CMD}
        DEPENDS ${YAML_FILE_PATH}
        COMMENT "Generating C++ interface for node '${NODE_NAME}'"
        VERBATIM
    )

    set(INTERFACE_LIB_NAME "${NODE_NAME}_interface")
    add_library(${INTERFACE_LIB_NAME} INTERFACE ${INTERFACE_HEADER_FILE})
    target_include_directories(
        ${INTERFACE_LIB_NAME} INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR}/include>
                                        $<INSTALL_INTERFACE:include>
    )
    set_target_properties(${INTERFACE_LIB_NAME} PROPERTIES LINKER_LANGUAGE CXX)
    target_link_libraries(${INTERFACE_LIB_NAME} INTERFACE rclcpp::rclcpp)

    # Install the generated headers
    install(DIRECTORY ${LIB_INCLUDE_DIR} DESTINATION include)

    # Export dependencies
    ament_export_dependencies(rclcpp)

    target_link_libraries(${CAKE_CPP_PACKAGE_TARGET} ${INTERFACE_LIB_NAME})

    message(STATUS "cake: Generated C++ interface library for node '${NODE_NAME}'")

    # generate_parameter_library expects a path relative to CMAKE_CURRENT_SOURCE_DIR Compute the relative path from
    # source to binary dir
    file(RELATIVE_PATH INTERFACE_PARAMS_FILE_REL ${CMAKE_CURRENT_SOURCE_DIR} ${INTERFACE_PARAMS_FILE})

    set(PARAMETERS_LIB_NAME "${NODE_NAME}_parameters")
    generate_parameter_library(${PARAMETERS_LIB_NAME} ${INTERFACE_PARAMS_FILE_REL})

    # Make parameters library depend on interface library (which generates the .params.yaml)
    add_dependencies(${PARAMETERS_LIB_NAME} ${INTERFACE_LIB_NAME})

    target_link_libraries(${CAKE_CPP_PACKAGE_TARGET} ${PARAMETERS_LIB_NAME})
    message(STATUS "cake: Generated parameters library for node '${NODE_NAME}'")

    # Register the node as an rclcpp component Convention: ${PROJECT_NAME}::${NODE_NAME}::${NodeNamePascal}
    _cake_snake_to_pascal(NODE_CLASS_NAME ${NODE_NAME})
    set(PLUGIN_CLASS "${PROJECT_NAME}::${NODE_NAME}::${NODE_CLASS_NAME}")

    rclcpp_components_register_node(${CAKE_CPP_PACKAGE_TARGET} PLUGIN ${PLUGIN_CLASS} EXECUTABLE ${NODE_NAME})
    message(STATUS "cake: Registered component '${PLUGIN_CLASS}' with executable '${NODE_NAME}'")
endfunction()

# Generate Python interface and executable wrapper Creates _interface.py, _parameters.py, and executable using
# runpy.run_module(). Installs to ${PYTHON_INSTALL_DIR}/${PROJECT_NAME}/${NODE_NAME}/ Args: NODE_NAME - Name of the node
# NODE_DIR - Full path to node directory INTERFACE_YAML - Path to interface.yaml file
function(_cake_generate_python_node NODE_NAME NODE_DIR INTERFACE_YAML)
    set(PYTHON_GEN_DIR ${CMAKE_CURRENT_BINARY_DIR}/python_generated/${NODE_NAME})
    file(MAKE_DIRECTORY ${PYTHON_GEN_DIR})

    # Generated files
    set(INTERFACE_PY ${PYTHON_GEN_DIR}/interface.py)
    set(PARAMETERS_INTERNAL_PY ${PYTHON_GEN_DIR}/_parameters.py)
    set(PARAMETERS_PY ${PYTHON_GEN_DIR}/parameters.py)
    set(INIT_PY ${PYTHON_GEN_DIR}/__init__.py)

    set(
        CODEGEN_CMD
        ${cake_codegen_script_BIN}
        ${INTERFACE_YAML}
        --language
        python
        --package
        ${PROJECT_NAME}
        --node-name
        ${NODE_NAME}
        --output
        ${PYTHON_GEN_DIR}
    )

    add_custom_command(
        OUTPUT ${INTERFACE_PY} ${PARAMETERS_INTERNAL_PY} ${PARAMETERS_PY} ${INIT_PY}
        COMMAND ${CODEGEN_CMD}
        DEPENDS ${INTERFACE_YAML}
        DEPENDS ${cake_codegen_script_BIN}
        COMMENT "Generating Python interface for node '${NODE_NAME}'"
        VERBATIM
    )

    add_custom_target(
        ${NODE_NAME}_interface ALL DEPENDS ${INTERFACE_PY} ${PARAMETERS_INTERNAL_PY} ${PARAMETERS_PY} ${INIT_PY}
    )

    # Install user Python files to site-packages/${PROJECT_NAME}/${NODE_NAME}/
    file(GLOB USER_PY_FILES "${NODE_DIR}/*.py")
    if(USER_PY_FILES)
        install(FILES ${USER_PY_FILES} DESTINATION "${PYTHON_INSTALL_DIR}/${PROJECT_NAME}/${NODE_NAME}")
        message(STATUS "cake: Installed user Python files for node '${NODE_NAME}'")
    endif()

    # Install generated Python interface files to site-packages/${PROJECT_NAME}/${NODE_NAME}/
    set(PYTHON_GEN_DIR "${CMAKE_CURRENT_BINARY_DIR}/python_generated/${NODE_NAME}")
    install(
        DIRECTORY ${PYTHON_GEN_DIR}/
        DESTINATION "${PYTHON_INSTALL_DIR}/${PROJECT_NAME}/${NODE_NAME}"
        FILES_MATCHING
        PATTERN "*.py"
    )

    # Generate wrapper executable using runpy.run_module()
    set(EXECUTABLE_PATH "${CMAKE_CURRENT_BINARY_DIR}/executables/${NODE_NAME}")
    file(
        WRITE ${EXECUTABLE_PATH}
        "#!/usr/bin/env python3
import runpy

# Run the node's main file as __main__
runpy.run_module('${PROJECT_NAME}.${NODE_NAME}.${NODE_NAME}', run_name='__main__')
"
    )

    # Make executable
    file(
        CHMOD
        ${EXECUTABLE_PATH}
        PERMISSIONS
        OWNER_READ
        OWNER_WRITE
        OWNER_EXECUTE
        GROUP_READ
        GROUP_EXECUTE
        WORLD_READ
        WORLD_EXECUTE
    )

    # Install executable to lib/${PROJECT_NAME}/ for ros2 run
    install(PROGRAMS ${EXECUTABLE_PATH} DESTINATION lib/${PROJECT_NAME})
endfunction()
